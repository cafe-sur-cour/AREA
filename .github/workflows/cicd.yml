name: CI/CD Pipeline

on:
  push: {}
  pull_request: {}


jobs:
  check_repository:
    name: Check repository to start jobs
    runs-on: ubuntu-latest
    outputs:
      target: ${{ steps.new_output.outputs.value }}
      backend_changed: ${{ steps.new_output.outputs.backend_changed }}
      web_changed: ${{ steps.new_output.outputs.web_changed }}
      mobile_changed: ${{ steps.new_output.outputs.mobile_changed }}
    steps:
      - name: checkout@v4
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check target repository
        id: new_output
        run: |
          temp=$(echo "$MIRROR_URL" | cut -d ':' -f 2 | sed "s/\.git//")
          if [ "$temp" = "${{ github.repository }}" ]; then
            echo "::notice title=The target repository is also the current one::$temp"
            echo "value=1" >> "$GITHUB_OUTPUT"
          else
            echo "value=0" >> "$GITHUB_OUTPUT"
          fi

          # Detect changed paths for push events; for pull requests, run all jobs
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            echo "backend_changed=true" >> "$GITHUB_OUTPUT"
            echo "web_changed=true" >> "$GITHUB_OUTPUT"
            echo "mobile_changed=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          BEFORE='${{ github.event.before }}'
          AFTER='${{ github.sha }}'

          # Ensure we have the refs available
          git fetch --no-tags --prune --depth=1 origin || true

          # If this push is a merge commit created by merging a PR, its commit
          # message usually contains "Merge pull request" (or similar). Treat
          # that as a PR-merge and run all jobs.
          commit_message=$(git log -1 --pretty=%B "${{ github.sha }}" 2>/dev/null || true)
          if echo "$commit_message" | grep -qE 'Merge pull request|Merged in|Merge branch'; then
            echo "Detected merge commit: $commit_message" >&2
            echo "backend_changed=true" >> "$GITHUB_OUTPUT"
            echo "web_changed=true" >> "$GITHUB_OUTPUT"
            echo "mobile_changed=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ -z "$BEFORE" ] || [ "$BEFORE" = "0000000000000000000000000000000000000000" ]; then
            changed_files=$(git ls-tree -r --name-only "$AFTER")
          else
            changed_files=$(git diff --name-only "$BEFORE" "$AFTER")
          fi

          echo "Changed files: $changed_files"

          if echo "$changed_files" | grep -qE '(^backend/)|(/backend/)'; then
            echo "backend_changed=true" >> "$GITHUB_OUTPUT"
          else
            echo "backend_changed=false" >> "$GITHUB_OUTPUT"
          fi

          if echo "$changed_files" | grep -qE '(^web/)|(/web/)'; then
            echo "web_changed=true" >> "$GITHUB_OUTPUT"
          else
            echo "web_changed=false" >> "$GITHUB_OUTPUT"
          fi

          if echo "$changed_files" | grep -qE '(^mobile/)|(/mobile/)'; then
            echo "mobile_changed=true" >> "$GITHUB_OUTPUT"
          else
            echo "mobile_changed=false" >> "$GITHUB_OUTPUT"
          fi

  backend-linter:
    name: Backend linter
    needs: check_repository
    if: ${{ needs.check_repository.outputs.target == 0 && needs.check_repository.outputs.backend_changed == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up NodeJs
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Install backend dependencies
        working-directory: ./backend
        run: npm install

      - name: Run backend ESLint
        working-directory: ./backend
        run: npm run lint

      - name: Run Prettier check
        working-directory: ./backend
        run: npm run format:check

  backend-test:
    name: Backend tests
    needs: backend-linter
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up NodeJs
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Install backend dependencies
        working-directory: ./backend
        run: npm install

      - name: Run backend tests
        working-directory: ./backend
        run: npm test

  web-linter:
    name: Web frontend linter
    needs: check_repository
    if: ${{ needs.check_repository.outputs.target == 0 && needs.check_repository.outputs.web_changed == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up NodeJs
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Install frontend dependencies
        working-directory: ./web
        run: npm install

      - name: Run frontend ESLint
        working-directory: ./web
        run: npm run lint

      - name: Run Prettier check
        working-directory: ./web
        run: npm run format:check

  mobile-linter:
    name: Mobile frontend linter
    needs: check_repository
    if: ${{ needs.check_repository.outputs.target == 0 && needs.check_repository.outputs.mobile_changed == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version-file: ./mobile/pubspec.yaml

      - name: Install mobile dependencies
        working-directory: ./mobile
        run: flutter pub get

      - name: Run mobile Dart analysis
        working-directory: ./mobile
        run: flutter analyze

  mobile-test:
    name: Mobile frontend tests
    needs: mobile-linter
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version-file: ./mobile/pubspec.yaml

      - name: Install mobile dependencies
        working-directory: ./mobile
        run: flutter pub get

      - name: Run mobile tests
        working-directory: ./mobile
        run: flutter test

  deploy-app:
    name: Deploy application
    needs: [backend-test, web-linter, mobile-test]
    if: ${{ needs.check_repository.outputs.backend_changed == 'true' || needs.check_repository.outputs.web_changed == 'true' || needs.check_repository.outputs.mobile_changed == 'true' }}
    runs-on: ubuntu-latest
    environment: AREA
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Temporary job
        run: echo "Temporary job to fix needs issue"

      - name: Generate .env from secrets
        env:
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_NAME: ${{ secrets.DB_NAME }}
          DB_PORT: ${{ secrets.DB_PORT }}
          NODE_PORT: ${{ secrets.NODE_PORT }}
          NEXT_PORT: ${{ secrets.NEXT_PORT }}
          FRONTEND_URL: ${{ secrets.FRONTEND_URL }}
          SERVICE_GITHUB_CLIENT_ID: ${{ secrets.SERVICE_GITHUB_CLIENT_ID }}
          SERVICE_GITHUB_CLIENT_SECRET: ${{ secrets.SERVICE_GITHUB_CLIENT_SECRET }}
          SERVICE_GITHUB_REDIRECT_URI: ${{ secrets.SERVICE_GITHUB_REDIRECT_URI }}
        run: |
          echo "DB_USER=$DB_USER" > ./deployment/.env
          echo "DB_PASSWORD=$DB_PASSWORD" >> ./deployment/.env
          echo "DB_NAME=$DB_NAME" >> ./deployment/.env
          echo "DB_PORT=$DB_PORT" >> ./deployment/.env
          echo "NODE_PORT=$NODE_PORT" >> ./deployment/.env
          echo "NEXT_PORT=$NEXT_PORT" >> ./deployment/.env
          echo "FRONTEND_URL=$FRONTEND_URL" >> ./deployment/.env
          echo "SERVICE_GITHUB_CLIENT_ID=$SERVICE_GITHUB_CLIENT_ID" >> ./deployment/.env
          echo "SERVICE_GITHUB_CLIENT_SECRET=$SERVICE_GITHUB_CLIENT_SECRET" >> ./deployment/.env
          echo "SERVICE_GITHUB_REDIRECT_URI=$SERVICE_GITHUB_REDIRECT_URI" >> ./deployment/.env

      - name: Clean all containers
        run: docker compose -f ./deployment/docker-compose.yml down -v

      - name: Deploy application
        run: docker compose -f ./deployment/docker-compose.yml up -d --build

      - name: Waiting for postgreSQL database
        run: timeout 60 bash -c "until docker exec postgres_db pg_isready -U $DB_USER -d $DB_NAME; do sleep 2; done"

      - name: Waiting for backend service
        run: timeout 60 bash -c 'until nc -z localhost ${{ secrets.NODE_PORT }}; do sleep 2; done'

      - name: Waiting for web service
        run: timeout 60 bash -c 'until nc -z localhost ${{ secrets.NEXT_PORT }}; do sleep 2; done'

      - name: List running containers
        run: docker ps

  build-and-push:
    # needs: [backend-test, web-linter, mobile-test]
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    strategy:
      matrix:
        component: [frontend, backend, mobile]

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check if Dockerfile exists
        id: check_dockerfile
        run: |
          if [ -f "./deployment/Dockerfile.${{ matrix.component }}" ]; then
            echo "dockerfile_exists=true" >> $GITHUB_OUTPUT
          else
            echo "dockerfile_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Set up Docker Buildx
        if: steps.check_dockerfile.outputs.dockerfile_exists == 'true'
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry
        if: steps.check_dockerfile.outputs.dockerfile_exists == 'true'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata for Docker
        if: steps.check_dockerfile.outputs.dockerfile_exists == 'true'
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}-${{ matrix.component }}
          tags: |
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}
            type=sha,format=short
            type=ref,event=tag

      - name: Build and push Docker image
        if: steps.check_dockerfile.outputs.dockerfile_exists == 'true'
        uses: docker/build-push-action@v5
        with:
          context: ./deployment
          file: Dockerfile.${{ matrix.component }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Image build skipped
        if: steps.check_dockerfile.outputs.dockerfile_exists == 'false'
        run: |
          echo "::notice::Dockerfile for ${{ matrix.component }} not found. Image build skipped."

  push-to-mirror:
    name: Push to Mirror Repository
    needs: deploy-app
    if: ${{ (github.event_name == 'pull_request' && github.event.pull_request.merged == true) || (github.event_name == 'push' && contains(github.event.head_commit.message, 'Merge pull request')) }}
    environment: PIPELINE
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Source Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Validate mirror repo secret
        run: |
          echo "Checking MIRROR_REPO secret..."
          if [ -z "${MIRROR_REPO}" ]; then
            echo "::error::secrets.MIRROR_REPO is empty"
            exit 1
          fi
          # Basic SSH URL sanity check (git@host:owner/repo.git)
          if ! echo "${MIRROR_REPO}" | grep -Eq '^[^@]+@[^:]+:[^/]+/.+(\.git)?$'; then
            echo "::warning::secrets.MIRROR_REPO does not look like an SSH URL (expected git@host:owner/repo.git)."
          fi
          if [ -z "${SSH_PRIVATE_KEY}" ]; then
            echo "::error::secrets.SSH_PRIVATE_KEY is empty"
            exit 1
          fi
        env:
          MIRROR_REPO: ${{ secrets.MIRROR_REPO }}
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
      - name: Push to Mirror Repository
        uses: pixta-dev/repository-mirroring-action@v1
        with:
          target_repo_url: ${{ secrets.MIRROR_REPO }}
          ssh_private_key: ${{ secrets.SSH_PRIVATE_KEY }}
          ssh_username: git
